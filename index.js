const os = require('os');
const fs = require('fs');
const path = require('path');
const { promisify } = require('util');
const { Cookie, CookieMap } = require('cookiefile');

const exec = promisify(require('child_process').exec);
const mkdir = promisify(fs.mkdir);
const readFile = promisify(fs.readFile);
const writeFile = promisify(fs.writeFile);

const CURL_EXEC = 'curl';

function WebWalker(workDir) {

  this.workDir = workDir;

  /**
   * generate a temporary file name in the working directory
   */
  this.tempFile = () => path.join(this.workDir, `${new Date().getTime()}-${Math.random()}`);

  /**
   * merge file
   */
  this.mergeFile = async (dest, ...srcs) => {
    let files = [dest].concat(srcs);
    let contents = [];
    for (let i = 0; i < files.length; ++i) {
      try {
        let content = await readFile(files[i], 'utf8');
        contents.push(content);
      } catch (ex) {}
    }
    await writeFile(dest, contents.join('\n'), 'utf8');
  }

  /**
   * merge cookies into one netscape format file
   * write results to the file represented by the first parameter
   */
  this.mergeCookies = async (files, objs) => {
    let cookieJar = this.tempFile();
    let cookieMap = new CookieMap();
    objs.forEach(cookie => {
      if (!!cookie) {
        cookieMap.set(new Cookie(cookie));
      }
    });
    cookieMap.save(cookieJar);
    await this.mergeFile(...files, cookieJar);
    return files[0];
  }

  /**
   * execute cURL command
   * TODO: use node cURL binding instead of command line
   */
  this.curl = async (url, request) => {
    let respFile = this.tempFile();
    let cookieFile = this.tempFile();
    let headerFile = this.tempFile();
    let params = [
      '--compressed',
      '--silent',
      '--location',
      `--output '${respFile}'`,
      `--cookie-jar '${cookieFile}'`,
      `--dump-header '${headerFile}'`
    ];

    // prepare cookies
    let cookies = request.cookies;
    if (typeof cookies === 'string') {
      // cookies stored in file (no '=' symbol appears in the argument), or,
      // cookies stored as plain string
      params.push(`--cookie '${cookies}'`)
    }
    if (typeof cookies === 'object') {
      // cookies stored as key value pairs
      let cookieArg = Object.getOwnPropertyNames(cookies).reduce((a, k) => {
        return a.concat(`${encodeURIComponent(k)}=${encodeURIComponent(cookies[k])}`);
      }, []);
      if (!!cookieArg.length) {
        params.push(`--cookie '${cookieArg.join('; ')}'`);
      }
    }

    // build headers
    let headers = request.headers || {};
    Object.getOwnPropertyNames(headers).map(k => params.push(`--header '${k}: ${headers[k]}'`));

    // build form data
    let formData = request.formData || {};
    let formDataArg = Object.getOwnPropertyNames(formData).reduce((a, k) => {
      return a.concat(`${encodeURIComponent(k)}=${encodeURIComponent(formData[k])}`);
    }, []);
    if (!!formDataArg.length) {
      params.push(`--data '${formDataArg.join('&')}'`);
    }

    await exec(`${CURL_EXEC} ${params.join(' ')} -- '${url}'`);
    return {
      response: respFile,
      cookies: cookieFile,
      headers: headerFile
    }
  }

  /**
   * walk through all steps in a configuration
   */
  this.walk = async (config) => {
    // there are 3 levels config:
    // global (0), static data specified at top level
    // step (1), static data specified in each step
    // dynamic (1), generated by the prepare() method in each step
    // data is merged before each request is executed, merge is shallow
    let headers0 = config.headers;
    let cookies0 = config.cookies;
    let formData0 = config.formData;
    // cookie is special, cookies from the response of each step are merged
    // explicit cookies in config are then merged too
    let cookieJar = this.tempFile();

    let stepResults = [];
    let lastStepResults = {};
    for (let i = 0; i < config.steps.length; ++i) {
      let step = config.steps[i];
      let headers1 = step.headers;
      let cookies1 = step.cookies;
      let formData1 = step.formData;

      let headers2 = {};
      let formData2 = {};
      let cookies2 = [];

      if (step.prepare) {
        let preparedResults = await step.prepare(lastStepResults, stepResults);
        headers2 = preparedResults.headers || {};
        formData2 = preparedResults.formData || {};
        cookies2 = preparedResults.cookies || [];
      }

      await this.mergeCookies([cookieJar, lastStepResults.cookies], [].concat(cookies0, cookies1, cookies2));

      let results = await this.curl(step.url, {
        headers: Object.assign({}, headers0, headers1, headers2),
        formData: Object.assign({}, formData0, formData1, formData2),
        cookies: cookieJar
      });

      if (step.process) {
        results.processed = await step.process(results.response, results.cookies, results.headers);
      }

      stepResults.push(results);
      lastStepResults = results;
    }

    return lastStepResults.processed;
  }
}

module.exports = async (config) => {
  let workDir = path.join(os.tmpdir(), `web-walker-${new Date().getTime()}-${Math.random()}`);
  let walker = new WebWalker(workDir);
  await mkdir(workDir);
  let results, exception;
  try {
    results = await walker.walk(config);
  } catch (ex) {
    exception = ex;
  }
  try {
    await exec(`rm -fr '${workDir}'`);
  } catch (ex) {}
  if (exception) {
    throw exception;
  }
  return results;
};
